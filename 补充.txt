- body
在common的body中设置position，min-width和max-width

但是貌似不设置position也是相对于body元素
min-width-主内容宽度
max-width-设计稿宽度

- width
一些需要占满的元素，例如nav、footer，直接设置width:100%

- cursor:pointer
可以点击的元素，需要添加

- &.[选择器名]
事件触发，动态添加的选择器，例如点击变色，设置交集选择器

- opacity:
当在父元素中添加opacity时，子元素也会受影响，解决：使用rgba代替opacity
background: rgba(0, 0, 0, .3);

- pre标签
保留空格和换行符
设置pre时，需设置样式
.pre-article {
    font-family: inherit;
    word-break: break-all;//任意字符换行
    white-space: pre-wrap;//处理空格，是否换行
}

white-space:
pre-wrap:都能识别换行空白符，其能识别多个空格
pre-line:多少空格都当做一个空格

- img
当图片的宽度为父元素宽度时，直接使用.img样式，当图片为图标或悬浮元素时，手动定义大小位置

- width
当盒子没有确定元素宽度时，默认继承父元素的宽度
min-width 的值会同时覆盖 max-width 和 width，此时子元素也继承了

- 分页器样式
设置分页器，设置swiper-pagination-bullet和swiper-pagination-bullet-active样式
&-pagi {
            display: flex;
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 25px;
            // TODO 在分页器中设置透明不起作用
            background: rgba(0, 0, 0, .3);
            justify-content: center;
            align-items: center;

            .swiper-pagination-bullet {
                width: 7px;
                height: 7px;
                background: #FFFFFF;
                border-radius: 50%;
                margin-right: 8px;
                opacity: 1;//分页器默认有透明的样式
            }

            .swiper-pagination-bullet-active {
                width: 7px;
                height: 7px;
                background: #FF4B50;
                border-radius: 50%;
                margin-right: 8px;
            }
        }

- 超出n行后显示省略号
display: -webkit-box;
-webkit-box-orient: vertical;
-webkit-line-clamp: 3;
overflow: hidden;

- 实现左右中布局
标题相对父元素居中，两端一个在最左，一个最右
法1：两端使用绝对定位，父元素使用flex，justify-content:center

 - 将图片放置在容器中
直接在div中使用img
img设置100%，可能不够长
在div中使用background，需加上
background: no-repeat;
background-size: cover;

- background-size：cover和background-size：100%的区别
100%是撑满整个容器，比例会变
cover是比例不变下，撑满整个容器

- 不设宽度时，汉字自动换行
white-space:nowrap;//强制永远不换行

- position和margin一起使用
position:absolute
left:0
right:0
margin:0 auto

- flex布局的缺点，宽度的省与写
1.flex盒子的内容可以溢出，即内容宽度可能超过父元素宽度（有些内容溢出不涉及宽度变化：比如 { width: 10px; white-space: nowrap;} ） 
2.若子元素写了 { overflow: hidden; }，则宽度不会溢出，文字内容也可以点点点。但会影响一些绝对定位等位置需要超出该元素的内容。

- 检查弹性盒子是否溢出
justify-content: center
若盒子移位了，表示溢出

- 防止弹性盒子溢出
overflow:hidden

- 当盒子A左右布局时，使用flex
左边a：flex: 0 0 auto 
右边a：flex: 1
右边盒子a里的内容或许会撑开右边a盒子，但是不改变盒子A
若想改善，可以设置右边盒子a的宽度，或者右边盒子a：overflow：hidden

- 伪元素--在input、radio、select不起作用
before的定义：在指定元素的内容之前插入内容。注意：是元素内容之前，而不是元素之前。
而input并不是容器，所以没有内容之前一说，所以就无效了。
&::before {
                content: "";
                position: absolute;
                top: 37px;
                left: -15px;
                display: block;
                width: 1px;
                height: 16px;
                background: #DDDDDD;
            }

- 不确定高度时居中
position: absolute;
        left: 50%;
        transform: translateX(-50%);

- 分散布局space-bewteen中实现最后一行左对齐
在父元素上，height一定要给0；width和item的width一致；conten给空即可
 &::after {
                    height: 0;
                    width: 20%;
                    min-width: 223px;
                    content: "";
                }
缺点：相当于手动给元素添加一个伪元素，促进它的居中，但是当一排不止三个元素时，失效，还是使用justify-content：left+margin-right吧


- 实现排列有两种方式
一是浮动，设置右边距，最后清除浮动
缺点：一排的最后一个右边距需清除，不一定能排到最后
二是flex布局，在最后一行设置左排
缺点：间距由父容器决定，一般是只有space-betwwen，间距不能超过一个子元素宽度

- 修改input【placeholder】
input::-webkit-input-placeholder{
    font-size: 25px;
    color: #2D3747;
    font-weight: bold;
}
input:-moz-placeholder{
    font-size: 25px;
    color: #2D3747;
    font-weight: bold;
} 
input::-moz-placeholder{
    font-size: 25px;
    color: #2D3747;
    font-weight: bold;
} 
input:-ms-input-placeholder{
    font-size: 25px;
    color: #2D3747;
    font-weight: bold;
}

- 图片居中
在一个盒子里只有一张图片
display: flex;
justify-content: center;
align-items: center; 

-当传入富文本时（接口数据包括html标签），直接使用v-html挂载的dom元素上
若是render传给子组件，则使用domProps:{innerHtml}


-label和input联合使用
label标签包裹input标签，点击label时，label两次响应，即label本身触发和input触发后冒泡到label上。
 

- Object.assign()的使用
可传入2~n个参数，第一个参数代表目标对象，其他的对象用于合并到目标对象，将对象中**可枚举属性**都分配到目标对象
const target = { a: 1, b: 2 };
const source = { b: 4, c: 5 };
Object.assign(target, source);//{ a : 1, b : 4 , c : 5}

- axios中的cancelToken，用于中断请求
const CancelToken = axios.CancelToken;
const source = CancelToken.source();
使用axios中的cancelToken取消上一次发送：
get请求cancelToken放在第二个参数；post请求cancelToken放在第三个参数。
axios.get('路径', {cancelToken}).then();
axios.get('路径', {参数},{cancelToken}).then();

- axios的拦截器和取消的区别
拦截器只是改变请求顺序，请求拦截器在发送请求前，响应拦截器在发送请求后、回调函数前
请求拦截区执行顺序自下往上，响应拦截执行顺序自上往下
请求拦截器2 ------请求拦截器1-------发送ajax请求-------响应拦截器1-------响应拦截器2------响应回调
取消。立刻取消发送请求

-vuex的使用
基本所有数据都存储在vuex中


- 被keep-alive包裹的组件的存在其他周期函数
activated
触发时机：keep-alive组件激活时使用，在mounted后；
deactivated
触发时机：keep-alive组件停用时调用，在组件切换、路由切换时调用，但再次切回时，由于没有触发destroy，不会触发created；

- 当数据挂载到，this.$set(obj, key, value)动态修改视图中的data属性

- iview中的render函数参数，第一个参数是h，第二个参数是一个包含row、column、index属性的对象params，覆盖直接渲染
on-sort-change：表格排序，有三个参数	
column：当前列数据
key：排序依据的指标
order：排序的顺序，值为 asc (升序)或 desc（降序）

- CLS，全称CommonLanguageSpecification，即公共语言规范。

- reflect：将对象内部的方法暴露，尤其是在对象原型上的方法，例如apply，has
Reflect.has(Obj,'num')//{num:'lyf'}:true

- exec() 用于匹配字符串，有则返回匹配值，无则null 
正则表达式：.->除换行符外任意字符 （）->表示在匹配成功后的取出里面的内容  *->出现0,1，n次

- 数组方法sort()：排序，根据传入的函数进行排序
传入一个负数时，不改变顺序，传入一个正数时，位置对调
若 a 小于 b，即 a - b 小于零，则返回一个小于零的值，数组将按照升序排列。
若 a 等于 b，则返回 0。
若 a 大于 b, 即 a - b 大于零，则返回一个大于零的值，数组将按照降序排列。

- 对象的解构赋值，直接拿取发送请求返回对象的data对象
对象的解构赋值，{ data: result } = { data: 'aaa', code : 'bbb' } = res;//result = 'aaa'

- 字符串比较大小：根据首字母的Ascii值

- subString（a，b）截取字符串的下标a到b的前一位

- Math.floor向下取整，保证最小取到第1条数据

- 函数注释：光标位于函数+ /** + enter

- class的静态方法：static

- date的valueOf()返回日期的原始值数字、toString()返回标准日期格式

- RegExp.$1 将最近的一次正则表达式存储，并可以调用子匹配，即括号内容
const r = /^(\d{4})-(\d{1,2})-(\d{1,2})$/
r.exec('2020-08-27')
RegExp.$1 //2020->\d{4}
RegExp.$2 // 08 ->\d{1,2}
RefExp.$3 // 27 ->\d{1,2}

- 正则表达式+和？的区别
*表示匹配0-无穷
+表示匹配1-无穷
？表示匹配0-1且尽可能短
var fmt = "yy-mm-dd";
/(y?)/.test(fmt)
RegExp.$1 //y
/(y+)/.test(fmt)
RegExp.$1 //yy

- for/in语句：循环对象的属性

- ccc Fri Aug 27 2021 00:00:00 GMT+0800 (中国标准时间)

- prevent.native

- 栅栏布局从小到大：xs sm md lg
xs = 24 //一个占24份，即一行只有一个
sm = 12 //一个占12份，即一行只有两个

- backgroud-position-x：背景图片相对于本来的位置偏移，正则往右偏移，负值则往左偏移，超出隐藏

- Vue.use的本质，执行传入参数的install函数

- 一个路由匹配到的所有路由记录会暴露为 $route 对象 (还有在导航守卫中的路由对象) 的 $route.matched 数组。
/parent/children // [{path:'/parent/children'},{path:'/parent'}]
即匹配某个子路由，也可以匹配到它的上一级路由

- 使用复制粘贴的插件clipboard
1，安装 npm i clipboard --save
2，配置clipboard文件
const clipboard = new Clipboard(event.target, {
    text: () => text,
  });
其中参数一表示触发复制事件的元素，参数二表示需要复制的text
on绑定成功和失败事件
clipboard.on("success", () => {
    Message.success("复制成功");
    clipboard.off("error");
    clipboard.off("success");
    clipboard.destroy();//释放内容
  });


- jq和js对dom的区别
jq拿取元素和js不同，js拿到的是DOM对象，jq拿到的是特有的jq对象，但是两者对象中的元素，同样都是dom对象
即 $('.div') != document.getElementsByClassName('div')
但 $('.div').[0] == document.getElementsByClassName('div')[0]
也就是说当动态的添加元素时，jq仍然只能拿到n个，但js能拿到n+1个，但是就已拿到的元素中，修改获取元素的属性，两者都能体现，因为操作的都是dom对象
<p>1</p>
<p>1</p>
<p>1</p>
<p>1</p>
此时，去拿p标签
var jq_p = $(p).length
var js_p = document.getElementsByTagName(p)
console.log(jq_p.length,js_p.length)
此时，都是4
若在p标签后再添加一个p
console.log(jq_p.length,js_p.length)
此时jq_p.length = 4,而js_p_length = 5

- css使用伪元素
.nav-item::before{
content:'',
display:block
}
移除：优先级=子元素>伪元素
 .nav-item:first-child::before {
            content: none;
        }


- 文字填写表格
当文本只有一行文本时居中，当有多行时居左
inline-block的特性：宽度由内部元素决定，但宽度小于其的父元素
自我理解：当子元素未满一行时，被父元素text-align居中，当子元素和父元素一样宽时，子元素text-align居左
text-align使inline-block居中，但当超过宽度时，则是由元素的text-align决定对齐方式，故修改父元素的对齐方式为left
<td class="per"><p class="next"></p></td>
.pre{
	text-align:center
}
.next{
	display:inline-block;
	text-align:left
}

- 第一个子元素的margin-top溢出
1，在父元素中使用padding不是子元素使用margin
2，父元素形成BFC
父元素:before
.margin-clear:before {
    content: "";
    display: table;
}

- console打印对象
当打印一个对象时，是打印它的最终形态，即浅拷贝，若需打印其当时的形态，可以使用复制
console.log({...obj})

- $el指的是vue挂载的组件
var app = new Vue({
  el: '#example',
  data: data
})
app.$data === data // => true
app.$el === document.getElementById('example') // => true

- this.$slots.[插槽名称] 
当父组件使用该组件时，this.slots是外层调用本组件传入的slot编译后的函数，反之undefined

- 使用h函数创建组件，传入一个子组件，子组件的事件需要通过emit发送出来，在父组件通过on属性接收
子组件： this.$emit('update:visible', false);
父组件： render(h) {
        return h(
            'div',
            {},
   	 [h(
                    Modal,
                    {
                        props: item,
                        on: {
                            'on-ok': () => {
                                item.onOk();
                                !item.okLoading && this.closeModal(item.name);
                            }
                        }
                    } 
                )]
            )
    }

- h函数中修改子组件的插槽内容，在第二个参数中加入：
scopedSlots: {
    default/具名插槽: （参数） => createElement('span',参数 )
  },

- v-model实现父子组件双向绑定
在父组件使用子组件时添加v-model
在子组件中通过props的value接收并挂载在dom上

- route：响应式，可以通过computed和watch监听

- DOMContentLoaded：页面加载完html，还没有加载样式js等

- export {a} from //其实是import和export的语法糖，只是将import省略，本页面无法获取a变量，只是导入又导出了

- 箭头函数的this
箭头函数没有this，需要沿上下文作用链寻找this
this->全局函数时，指向window
this->匿名函数时，指向自身，找不到则window

- vue组件中，事件修饰符
.stop 阻止冒泡事件
.native 自定义组件的原生事件
.sync 子组件修改父组件数据

- 组件的click事件和点击事件
当使用render函数渲染组件、组件定义click事件、组件库的click
已经不是按钮原生点击事件，只是和click同名，被emit发送出来的
故以上三个中，@click.naive和@click不同
且在这种情况下，也无法使用vue中其他修饰符，因为并不真是click

- 调试vue中事件和属性
mounted(){window.vue = this}
在console中输入
vue.[属性]

- 找出数组最大最小项的js方法
1，Math.max()
缺点：不可以传入数组，只能传入数组项
Math.max(arr)//error
Math.max(10,20,30)//30
2，eval()方法
执行方法里的参数，参数只能是字符串，将字符串作为js编译
eval('Math.max(' + arr.toString() + ')')

- 当事件绑定函数时，传入对象方法（obj.meth）/函数(fun)的区别
1，@click = 'add'   =>  @click="val =>{ add(val) }"
设定一个参数为$event接收，等同于以上的val =》@click = 'add($event)'
当绑定的是对象的方法时，影响this指向，一般都需要带括号，传入函数时不影响
3，@click = 'obj.add()' !== @click='obj.add'

- 参数对象含有方法function属性时
需要使用本对象obj中的this时，使用function，当需要使用data的作用域时，使用箭头函数，本对象则使用this.obj.XX

- lorem :自动数据填充 lorem[单词长度]+tab
撤销：ctrl+z 取消撤销：ctrl+y

- Date函数
new Dtae(）
传入同一个时间的不同形式，getTime()得到的结果一样，但是本质不同
new Date('December 17, 1995 03:24:00') != new Date('1995-12-17T03:24:00');
可传参，传入一个时间或时间戳，将其转换为标准时间格式，不传则是当前时间的标准时间格式
标准时间格式：Fri Sep 10 2021 11:42:10 GMT+0800 (中国标准时间)
星期几 几月 几号 年份 时间 区号
var date = new Date()//Tue Sep 07 2021 14:10:34 GMT+0800 (中国标准时间)
date = date.getTime()//1630995157846

- 如何使用echart
1，安装echart
2，在dom元素中添加refs ref='chartPart'
3，初始化echart echarts.init(chartPart)
4，配置图表数据setOption
- 配置项：series数组，每一项为一个对象->代表一个图形
 - - 属性：type：常见的值有pie/line/bar、分别代表饼状图、折线图、柱形图

- flex的三个属性
flex-grow:放大比例
flex-shrink:缩小比例
flex-basis:项目在主轴上初始大小 auto:足够容纳的最小空间
优先级：flex-basis >width
flex: 0 0 auto //不放大也不缩小，为最小盒子
flex: 1//自适应布局，根据父容器放大缩小
面试题：flex：1 即为flex-grow：1，经常用作自适应布局，将父容器的display：flex，侧边栏大小固定后，将内容区flex：1，内容区则会自动放大占满剩余空间。

- rem布局和em布局
都是响应式，但是相对的元素不同
- em布局：the element 相对于父元素大小的单位
- rem布局：root elemnt 根元素：相对根元素html字体大小的单位 => 1rem = html:font-size px
font-size 将屏幕分为100份，每一个font-size占1份，即html元素字体的大小，恒等于屏幕宽度的1/100
font-size = 设备尺寸/设计图尺寸*100 = (clinetWidth/750)*100 = clinetWidth/7.5
设计尺寸：设备尺寸/设计图尺寸
**js实现rem布局**
function remComputed() {
    let width = document.documentElement.clientWidth;
    width = width > 750 ? width : 750;//750为是设计稿
    document.documentElement.style.fontSize = width / 7.5 + 'px';
}
window.addEventListener('resize', remComputed);//监听显示器变化

- jpg和png的区别
jpg小png大，jpg有损，png无损

- inline-block和block和inline的区别
inline：不换行，width和height不起作用，
block：默认占一行，默认宽度Wie父元素宽度，有margin、padding
inline-block：可以设置宽高，但是不默认换行
**补充**：inline-block不换行，和浮动效果float:left类似，但是会将空白回车当做内容，出现4px的空白间隙，例如image就会产生这种情况
消除空白间隙：父元素添加{font-size:0}

- beyong compare 工具的使用
用于对比文件/文件夹内容，从文件资源管理器中拖拽

- render函数对于按钮组件Button的渲染和传值
render函数常用来自定义table。Button为组件，已经封装完毕，直接使用时，size和type是挂载在子组件上，实际为传值，故render写在props上
h('Button',{props:{size:'small',type:'text'}})
组件事件由on属性监听:on:{click()=>{this.handle()}}
h函数：参数一：dom元素字符串；参数二：dom元素属性对象；参数三：数组/字符串，数组中也能存数组
h( "div", {
                style: {
                    color: "red",
                    width: "140px",
                    height: "140px",
                }
            },[])
 props和domProps的区别 
 - props传给子组件
 - domProps传给dom元素

- ivew组件库的缺点
有些组件无法通过添加选择器class='input'的方式修改样式，要么使用内联样式style='width:200px'，要么找到iview组件库的样式.ivu-input-wrapper{}

- 项目dom触发事件中的方法总是带参数
方法的复用性，若是有两个列表使用两个datalist，可以复用一个方法，传各自的datalist

- forEach
forEach没有返回值，在forEach中使用return，无法接收，只能终止循环
var arr = [1, 2, 3];
      function fun() {
        var num = arr.forEach((item) => {
          if (item > 1) {
            return false;
          } else {
            console.log(item);
          }
        });
        return num;//undefined
      }
      console.log(fun());//undefined


-  表格数据快速过滤
形如 [{},{},{}]
遍历每一项过滤filter出需要的项，再使用map拿出
-- filter方法：返回一个新数组，元素是函数返回true的数组元素
-- map方法：返回一个新数组，元素是**函数**的返回值
arr.map(x=>x)//返回与原来一模一样的新数组
arr.filter(x=> x>12).map(x=>x.name)

-  两个表格数据快速匹配
item.channel_list.filter(
                item => osList.indexOf(item.os) > -1
            );


- hasOwnProperty方法
对象调用，判断本对象是否包含该属性，只在对象中查找，并不在原型中寻找，返回boolean值
- obj.hasOwnPropety('name')// true/false
foo.hasOwnProperty(“bar”) 应该替换为 Object.prototype.hasOwnProperty.call(foo, “bar”)。

- XMLHttpRequest对象
用于发送http请求，ajax基于XMLHttpRequest对象
-- upload 只读，代表上传进度
        下载的progress事件属于XMLHttpRequest对象，上传的progress事件属于XMLHttpRequest.upload对象。
        xhr.onprogress
        xhr.upload.onprogress
-- withCredentials 布尔值，用来指定跨域 Access-Control 请求是否应当带有授权信息，如 cookie 或授权 header 头。
常见触发事件
onprogress ->监听数据传输进行中事件，触发后执行事件函数
onerror -> 监听请求失败事件，触发后执行事件函数
onload ->监听请求成功事件，状态码为200，触发后执行事件函数


- class和style绑定
数组式：class列表->[active]
对象式：属性值为true/false->{ active: false }
混用式：数组+对象->[{ active: false }, errorClass]

- Array.prototype.slice.call
将类数组的对象/集合转为数组
将类数组转为数组（类数组：属性为数组下标、拥有length属性）
{
	0: {uid: 1633675851143}
	1:{uid: 1633675851145}
	length: 2
}
-- Array.prototype.slice.call
-- Array.from

- Object.prototype.toString.call
判断参数的数据类型，返回[object type]

- pop
修改原数组，删除数组最后一个，并返回删除的那个项

- formData
FormData对象用以将数据编译成键值对，以便用XMLHttpRequest来发送数据，常用于send(formData)
使用：append添加字段-> formData.append('name',lyf)

- 拖拽元素所触发的事件
-- 在拖动目标上触发事件 (源元素):
ondragstart - 用户开始拖动元素时触发
ondrag - 元素正在拖动时触发
ondragend - 用户完成元素拖动后触发

-- 释放目标时触发的事件:
ondragenter - 当被鼠标拖动的对象进入其容器范围内时触发此事件
ondragover - 当某被拖动的对象在另一对象容器范围内拖动时触发此事件
ondragleave - 当被鼠标拖动的对象离开其容器范围内时触发此事件
ondrop - 在一个拖动过程中，释放鼠标键时触发此事件

- 拖拽元素所触发的数据
被拖拽的元素产生Datatransfer对象，用于保存拖拽的信息
-- files 被包含数据传输中可用的所有本地文件的列表

- 如何修改iview源码
不能直接在node-modules修改，因为iview作为项目，使用的是打包后dist，故需在源码上修改，打包后替换node-module的iview
iview安装依赖出错：npm install 报错->ReferenceError: primordials is not defined
原因：node版本过高

- [].every()
测试一个数组能否全部通过测试，若出现不合法的项，返回false，直接退出整体返回false
例如：a = [1,2,3].every(item=>item%2 = 0)//当进行第一次循环时，就不合法，返回false，退出循环，a = false

- [].some()
测试一个数组是否有通过的一项，若出现返回true，退出循环。
b.some(item=> item=== a)//判断包含于，属性a包含于b数组

- iview封装dispatch事件
function dispatch(componentName, eventName, params) {
			// 寻找父组件 找不到则返回根组件
            let parent = this.$parent || this.$root;
            // 返回组件名称 
            let name = parent.$options.name;
			// 寻找指定名称的父组件
            while (parent && (!name || name !== componentName)) {
                parent = parent.$parent;

                if (parent) {
                    name = parent.$options.name;
                }
            }
            // 找到则触发指定的事件
            if (parent) {
                parent.$emit.apply(parent, [eventName].concat(params));
            }
        },


- for循环中使用return
在Java中只有函数可以使用return， 但js中for是没有局部作用域的概念的，
所以只有把for循环放在函数中时，才可以在for循环中使用return语句，实际上是整个函数终止了，故多层循环也是直接退出了

- cookies和localStorage和sessionStorage
设置一般都是get[Item]、set[Item]、remove[Item]
cookies保存在浏览器，浏览器关则关、有期限，有大小限制
sessionStorage为临时保存，而localStorage为永久保存。
sessionid：当登录时，服务器会为客户端创建一个 session，并算出sessionID，用来标识该对象

- 获取事件函数的事件对象，不能随便使用参数，只能使用$event

- input[type = file]
获取已上传列表 this.$refs.input.files 会得到 FileList类数组对象，保存着name、type

- 字符串转数组并用逗号分割
arr.join(',')

- es6对象解构默认赋值
let {num =  1} = {num:'luoyufeng' }
当右边不存在num时，默认num = 1，当右边存在num时，将右边的赋值给num = 'luoyufeng'

- vueconfig和jsconfig的区别
vscode的配置
vue的配置

- 字符串切割数组slice和substring和substr的区别
-- slice：参数可以是负值（负值 = 负值+字符串长度），但参数二大于参数一
--substring：参数不能是负值，但是参数大小不固定，当参数二大于参数一时，调换
--substr：不怎么使用，参数二表示截取长度

- 变量提升
变量提升指的的声明提升，赋值没有提升，但是声明式函数（function num(){}）同时提升变量名和函数体
函数声明方式：声明式：function num(){}、表达式 let fun = function(){}、new构造式

- js事件循环
函数、console、promise.then、settimeout的执行顺序
then在前三个后，setimeout最后
所有会进入的异步都是指的事件回调中的那部分代码，其中then和settimeout都是回调函数是异步的
同步任务在一个栈中，异步任务在任务队列中，当异步任务搞定后，且同步任务搞定后，系统将它推入栈底执行
- 宏任务和微任务
宏任务由浏览器发起（settimeout），微任务js发起，特指promise.then
执行顺序：先执行宏任务，再执行微任务，下一次循环，即微任务在宏任务和宏任务之间执行

- instanceof和typeof的区别
instanceof 检测对象A是不是对象B的实例的原理是：
查看对象B的prototype指向的对象是否在对象A的prototype链上。如果在，则返回true,如果不在则返回false。
不过有一个特殊的情况，当对象B的prototype为null将会报错(类似于空指针异常)。


- 事件委托
一个事件处理函数，绑定一类事件
$('.btn').forEach(item =>{item.onclick = ()=> })

- async awiat
用于优化链式调用，链式调用只能调用上一个promise的reslove出来的参数，await可以不限使用，弱化了链的存在，更像是平行的
awiat 
必须和async搭配，若promise对象没有resolve或reject，后面的代码不会执行。
若promise返回一个reject，则await需使用catch捕获，否则报错
若promise返回一个reslove，await后的代码也会在外部同步代码后执行
async
执行顺序：执行-》await-》外部同步代码-》await之后
可以没有await，就按照正常顺序执行
函数会返回一个promise，并且Promise对象的状态值是resolved（成功的），故await可以等待一个async函数

- class的构造函数
constructor是类固有的属性，返回实例对象，若自定义实例对象，若返回一个全新的对象，实例对象会不是类的实例。

- prototype和__proto__
__proto__（隐式原型）与prototype（显式原型）
prototype指向原型对象，是构造函数属性，所有的实例对象共享同一个prototype对象，修改prototype就是修改所有实例对象实现了继承
__proto__是所有对象都有的属性，构造器的原型，当找不到时就沿着原型寻找，最终形成原型链__proto__.__proto__.__proto__——>null (Object)
__proto__ === constructor.prototype
一个对象的隐式原型（__proto__）指向构造该对象的构造函数的原型（prototype）
let fun = new Fun()
fun.__proto__ = Fun.prototype
Fun.prototype.constructor = Fun
fun.constructor = Fun
Array.prototype.__proto__ === Object.prototype //true

- switch修改if大于等于小于
switch (true)
{
    case (scrollleft > 1000):
      alert('gt');
      break;
    case (scrollleft < 1000):
      alert('lt');
      break; 
    case (scrollleft == 1000):
      alert('lt');
      break; 
}


 - call和apply
参数1作为函数调用时使用的this，对于参数1不包含而函数包含的属性，仍为undefined
参数2~n作为函数调用时需要的参数
var person = {
    firstName:"John",
    lastName: "Doe",
    lastName1: "Doe",
    fullName: function(x) {
        this.x = x//因为this指的是person2，此时person2.x = x
        return this.firstName + " " + this.lastName+" "+x+ " " + this.lastName1;//正常调用使用person的
    }
}
person.fullName.call(person2,x)//使用person2的firstName那些，没有找到就undefined

- 构造函数
js中任何的函数都可以作为构造函数存在，使用new实例化会返回一个新的对象，但是直接执行一个函数，不一定会有return值
class 为 构造函数的语法糖，class 的本质也是构造函数。class的继承 extends  本质 为构造函数的原型链的继承。


- new函数
function newTest (Fun){
　　　　　　let obj = {};//后台会隐式执行new Object()创建对象;
　　　　　　obj.__proto__ = Fun.prototype;//继承其原型链
	   Fun.apply(obj,arguments);//将构造函数的作用域给新对象
　　　　　　return return obj;　//返回新对象
　　　　}

- 装饰器
添加@方法名装饰一些对象，可以装饰类，属性，方法
-- 装饰类
装饰器是一个函数，参数就是被装饰的类，若想在函数中额外传入参数
@test
class Class{}
fucntion test(target){}//target就是类class，可以在类Class上添加属性
fucntion test(value){ return function(target) { }}//vaule是调用装饰器时传入的参数，target就是类Class，每次调用装饰器，都会修改类
-- 装饰方法或类的属性
装饰器会修改属性的描述对象（descriptor），然后被修改的描述对象再用来定义属性，对于多个装饰器装饰同一属性，从上往下开始直到return前，从内到外开始return
参数1：对象原型，参数2：被修饰的属性名，参数3：描述对象
function test(target,name,descriptor){}//对象原型，装饰的属性名，描述对象
function test(value){ return (target,name,descriptor)=>{}}//传入参数
无法修饰函数，因为函数会变量提升，导致装饰器无法真正修饰到


-属性描述符对象
可以展示一个对象除了value外的其他属性，方法装饰器将其作为参数传入装饰器
getOwnPropertyDescriptor(对象,'属性值')
--configurable: 是否可删除
--enumerable: 是否可枚举(遍历)
--value: 属性值
--writable: 是否可修改

- render和map
map将数组映射为新数组，而render第三个参数就是数组


- 对于事件需要使用到回调参数$event的，使用
@input="e => {templateValueChange(e, item);}"//原本，e任意命名
@input="templateValueChange($event,item)"//$event固定名称

- v-for必须绑定key，key选择index


如何使用plantuml
1 下载java
2 下载graphviz

- 如何让vscode中的代码换行
"markdown.preview.breaks": true